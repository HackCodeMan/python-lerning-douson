class People: #Создание класса People
    """Virtual person"""
    total = 0 # Атрибут КЛАССА
    #В отличие от обычных они дефолтны для каждого объекта этого класса, в то время как обычные все индивидуальные
    #Их можно изменять
    def __init__(self, name, age): #Создание метода конструктора (Будет срабатывать после создания объекта)
        print("Новый человечек появился на свет")
        # Поля класса
        self.name = name
        self.age = age
        People.total += 1 #Изменение атрибута класса

    def __str__(self): # При просьбе распечатать объект функцией print() Он выведет то что возвращается функцией
        text_for_display = "Объект класса People\nИмя:" + self.name +"\nВозраст:" + str(self.age)
        return text_for_display

    #Создание прочих методов
    @staticmethod
    #декоратор @staticmethod превращает метод, определенный внутри класса, в обычную функцию,
    #которая не имеет доступа к экземпляру класса self ,
    #поэтому ее можно вызывать без создания экземпляра класса.
    def status(): #Статический метод не относящийся к объектам, а только к классу
        print("я по счету", People.total,"человечек")

    def talk(self):
        print("\nМеня зовут", self.name)
        print("Я отношусь к классу человек")
        print("И мне", self.age,"годиков")

#Создание объектов
obj1 = People("Антон",15)
People.status()
obj2 = People("Аня", 10)
People.status()
# Вызов методов объекта
obj1.talk()
obj2.talk()
# Вывод свойства объекта (Все атрибуты объекта доступны в свободном доступе). Их можно изменить или прочитать
print("Всего человечков ",People.total)
#Значение аргумента total будет одинаковым у обоих объектов, тк это одна и та же переменная line 3
print(obj1.total)# Запись с таким обращение не возможна, только так People.total
print(obj2.total)
#Вывод объекта на экран
print("\nОбъект obj1:\n", obj1, sep= "") #Работает функция __str__()

input("\n\nНажмите 'Enter' чтобы выйти")